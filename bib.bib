
@article{Brzozowski64,
    author = {Janusz A. Brzozowski},
    title = {Derivatives of regular expressions},
    journal = {Journal of the ACM},
    year = {1964},
    volume = {11},
    Qpages = {481--494}
}

@article{Elliott-2018-ad-icfp,
  author    = {Conal Elliott},
  title     = {\href{http://conal.net/papers/essence-of-ad/}{The simple essence of automatic differentiation}},
  journal   = {Proceedings of the ACM on Programming Languages},
  volume    = {2},
  number    = {ICFP},
  articleno = {4},
  numpages  = {29},
  month     = sep,
  year      = {2018},
}

@article{Elliott-2018-ad-extended,
  author  = {Conal Elliott},
  title   = {\href{https://arxiv.org/abs/1804.00746}{The simple essence of automatic differentiation (Extended version)}},
  journal ={CoRR},
  mon     = apr,
  year    = {2018},
  volume  = {abs/1804.00746}
}

@techreport{Elliott-2009-tcm,
  author      = {Conal Elliott},
  title       = {\href{http://conal.net/papers/type-class-morphisms}{Denotational design with type class morphisms\out{ (extended version)}}},
  institution = {LambdaPix},
  month       = {March},
  number      = {2009-01},
  year        = 2009
}

@article{HuttonMeijer-98-parsing,
  author = "Graham Hutton and Erik Meijer",
  title = {\href{http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf}{Monadic Parsing in Haskell}},
  journal = "Journal of Functional Programming",
  volume = 8,
  number = 4,
  year = 1998,
  month = jul,
  Qpublisher = "Cambridge University Press",
  Qpages = "437--444"
}

@InProceedings{Wadler-85-successes,
  author="Philip Wadler",
  Qeditor="Jouannaud, Jean-Pierre",
  title={{How to replace failure by a list of successes}},
  moreTitle={{: A method for exception handling, backtracking, and pattern matching in lazy functional languages}},
  booktitle="Functional Programming Languages and Computer Architecture",
  year="1985",
  Qpublisher="Springer Berlin Heidelberg",
  Qaddress="Berlin, Heidelberg",
  Qpages="113--128",
  abstract="Should special features for exception handling, backtracking, or pattern matching be included in a programming language? This paper presents a method whereby some programs that use these features can be re-written in a functional language with lazy evaluation, without the use of any special features. This method may be of use for practicing functional programmers; in addition, it provides further evidence of the power of lazy evaluation. The method itself is straightforward: each term that may raise an exception or backtrack is replaced by a term that returns a list of values. In the special case of pattern matching without backtracking, the method can be applied even if lazy evaluation is not present. The method should be suitable for applications such as theorem proving using tacticals, as in ML/LCF.",
  Qisbn="978-3-540-39677-2"
}

